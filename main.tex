\documentclass{beamer}

%
% Choose how your presentation looks.
%
% For more themes, color themes and font themes, see:
% http://deic.uab.es/~iblanes/beamer_gallery/index_by_theme.html
%
\mode<presentation>
{
  \usetheme{default}      % or try Darmstadt, Madrid, Warsaw, ...
  \usecolortheme{default} % or try albatross, beaver, crane, ...
  \usefonttheme{default}  % or try serif, structurebold, ...
  \setbeamertemplate{navigation symbols}{}
  \setbeamertemplate{caption}[numbered]
  \setbeamertemplate{footline}[page number]
  \setbeamercolor{frametitle}{fg=white}
  \setbeamercolor{footline}{fg=black}
} 

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{tikz}
\usepackage{listings}
\usepackage{courier}
\usepackage{minted}

\xdefinecolor{darkblue}{rgb}{0.1,0.1,0.7}
\xdefinecolor{darkred}{rgb}{0.7,0,0}
\xdefinecolor{dianablue}{rgb}{0.18,0.24,0.31}
\definecolor{commentgreen}{rgb}{0,0.6,0}
\definecolor{stringmauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},      % choose the background color
  basicstyle=\ttfamily\small,         % size of fonts used for the code
  breaklines=true,                    % automatic line breaking only at whitespace
  captionpos=b,                       % sets the caption-position to bottom
  commentstyle=\color{commentgreen},  % comment style
  escapeinside={\%*}{*)},             % if you want to add LaTeX within your code
  keywordstyle=\color{blue},          % keyword style
  stringstyle=\color{stringmauve},    % string literal style
  showstringspaces=false,
  showlines=true
}

\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}

\title[2016-12-12-femtocode-at-diana]{Femtocode: early development of a query language for HEP}
\author{Jim Pivarski}
\institute{Princeton -- DIANA}
\date{December 12, 2016}

\begin{document}

\logo{\pgfputat{\pgfxy(0.11, 8)}{\pgfbox[right,base]{\tikz{\filldraw[fill=dianablue, draw=none] (0 cm, 0 cm) rectangle (50 cm, 1 cm);}}}\pgfputat{\pgfxy(0.11, -0.6)}{\pgfbox[right,base]{\tikz{\filldraw[fill=dianablue, draw=none] (0 cm, 0 cm) rectangle (50 cm, 1 cm);}\includegraphics[height=0.99 cm]{diana-hep-logo.png}\tikz{\filldraw[fill=dianablue, draw=none] (0 cm, 0 cm) rectangle (4.9 cm, 1 cm);}}}}

\begin{frame}
  \titlepage
\end{frame}

\logo{\pgfputat{\pgfxy(0.11, 8)}{\pgfbox[right,base]{\tikz{\filldraw[fill=dianablue, draw=none] (0 cm, 0 cm) rectangle (50 cm, 1 cm);}\includegraphics[height=1 cm]{diana-hep-logo.png}}}}

% Uncomment these lines for an automatically generated outline.
%\begin{frame}{Outline}
%  \tableofcontents
%\end{frame}

%% \begin{frame}{Motivations}
%% \textcolor{darkblue}{\underline{Specific motivation}: accelerate data pulls, both}

%% \begin{center}
%% \begin{columns}
%% \column{0.1\linewidth}

%% \column{0.28\linewidth}
%% \centering \textcolor{darkblue}{for the humans}

%% {\it shorter time from concept to code}

%% \column{0.05\linewidth}
%% \centering \textcolor{darkblue}{and}

%% \column{0.28\linewidth}
%% \centering \textcolor{darkblue}{for the computers.}

%% {\it shorter time from code to results}

%% \column{0.1\linewidth}
%% \end{columns}
%% \end{center}

%% \vspace{0.2 cm}
%% \textcolor{gray}{(By ``data pull,'' I mean extract, transform, and filter data from a collaboration's central dataset and download it for further processing.)}

%% \vspace{0.5 cm}
%% \begin{uncoverenv}<2->
%% \textcolor{darkblue}{``\underline{Chip on my shoulder}''}

%% \vspace{0.2 cm}
%% To show that a very high-level, abstract view of computation can nevertheless be fast.
%% \end{uncoverenv}
%% \end{frame}

%% \begin{frame}[fragile]{High-level and speed are not antithetical}
%% \vspace{0.5 cm}
%% \begin{columns}
%% \column{0.55\linewidth}
%% Code like

%% \small
%% \begin{minted}{scala}
%% bestmuon =
%%   muons.filter(m => m.iso > 10)
%%        .maxBy(m => m.pt)
%% \end{minted}
%% \vspace{0.4 cm}

%% \column{0.35\linewidth}
%% \\ does {\it not} need to create function objects or muon objects at runtime!

%% \vspace{0.2 cm}
%% It need not be ``taken literally.''
%% \end{columns}

%% \vspace{0.5 cm}
%% \textcolor{darkblue}{Another possible execution plan:}
%% \begin{enumerate}
%% \item Start with all {\tt\small muon.iso} values in one array, all {\tt\small muon.pt} values in another array, and a ``repetition level'' to specify where events begin and end.
%% \item Apply the contents of the filter function to make a mask.
%% \item Use the mask and repetition level to compact the {\tt\small muon.pt} into zero or one results per event.
%% \end{enumerate}
%% \end{frame}

%% \begin{frame}{How fast {\it should} it be?}
%% \vspace{0.3 cm}
%% \textcolor{darkblue}{Suppose we want to plot all CMS $t\bar{t}$ data ever collected.}
%% \begin{itemize}
%% \item About 100~fb$^{-1}$ (\href{http://cms-service-lumi.web.cern.ch/cms-service-lumi/publicplots/int_lumi_cumulative_pp_1.png}{\textcolor{blue}{plot}}) $\times$ 1~nb (\href{https://atlas.web.cern.ch/Atlas/GROUPS/PHYSICS/CombinedSummaryPlots/SM/ATLAS_p_SMSummary_SqrtS_Zoom/ATLAS_p_SMSummary_SqrtS_Zoom.png}{\textcolor{blue}{plot}}) is 100 million events.
%% \item Derivation of plotted quantity could involve $\mathcal{O}(100)$ double-precision values per event.
%% \item That's only 80~GB of data that needs to be evaluated; anything else is overhead.
%% \end{itemize}

%% \vspace{0.5 cm}
%% \textcolor{darkblue}{{\it Single} computer, {\it single} thread:}

%% \vspace{0.1 cm}
%% \begin{description}
%% \item[load from disk:] 21 minutes (Numpy), 22 minutes (ROOT)
%% \item[CPU execution:] 70 seconds (no optimization), 13 seconds ({\tt -O3})
%% \item[GPU execution:] 12 seconds to copy to GPU, 5 seconds to compute
%% \end{description}

%% \vspace{0.1 cm}
%% \textcolor{gray}{(Probably close to ``theoretical minimum,'' centralized, distributed processing can help, as can caching.)}
%% \end{frame}

%% \begin{frame}{Role of language}
%% \vspace{0.5 cm}
%% Directly filling histograms from the collaboration-wide repository, eliminating private skims, would fundamentally improve analysis workflows. Analysis could become ``interactive.''

%% \vspace{0.5 cm}
%% \textcolor{darkblue}{How can a language help?}

%% \vspace{0.3 cm}
%% \begin{itemize}
%% \item Writing vectorized, one-array-at-a-time algorithms is unnatural.
%% \item Physicists {\it should} be thinking about one event at a time and muon {\it objects.}
%% \end{itemize}

%% \begin{center}
%% \begin{minipage}{0.7\linewidth}
%% \textcolor{darkblue}{$\to$ Transforming human concepts into physical execution is what programming languages do.}
%% \end{minipage}
%% \end{center}
%% \end{frame}

%% \begin{frame}{What's wrong with the languages we have?}
%% \vspace{0.25 cm}
%% As I said in my June 20 talk, C++ and Python are too expressive to permit these kinds of optimizations.

%% \vspace{0.2 cm}
%% Automatic vectorization is (in general) an unsolved problem in computer science. But building a vectorizable language is relatively easy: they're just less capable. Typically, query languages are vectorizable.

%% \vspace{0.5 cm}
%% Business intelligence with SQL is typically ``interactive,'' and big data projects are pushing $\mathcal{O}(\mbox{second})$ response times to petabyte scales: Ibis, Impala, Kudu, Drill, \ldots\ others? (\href{http://research.google.com/pubs/pub36632.html}{\textcolor{blue}{Google paper}}).

%% \vspace{0.5 cm}
%% \textcolor{darkblue}{However, SQL and its relatives are not sufficient for us.}
%% \end{frame}

%% \begin{frame}[fragile]{Nested query in SQL}
%% \vspace{0.5 cm}
%% {\bf Example query:}
%% \begin{center}
%% \begin{minipage}{0.95\linewidth}
%% \textcolor{darkblue}{``Momentum of the track with $|\eta|$ $<$ 2.4 that has the most hits.''}
%% \end{minipage}
%% \end{center}
%% \small
%% \begin{minted}{sql}
%% WITH hit_stats AS (
%%   SELECT hit.track_id, COUNT(*) AS hit_count FROM hit
%%     GROUP BY hit.track_id),
%%  track_sorted AS (
%%     SELECT track.*, 
%%     ROW_NUMBER() OVER (
%%      PARTITION BY track.event_id
%%      ORDER BY hit_stats.hit_count DESC)
%%   track_ordinal FROM track INNER JOIN hit_stats
%%     ON hit_stats.track_id = track.id
%%     WHERE ABS(track.eta) < 2.4)
%%  SELECT * FROM event INNER JOIN track_sorted
%%    ON track_sorted.event_id = event.id
%% WHERE
%%   track_sorted.track_ordinal = 1
%% \end{minted}
%% \end{frame}

%% \begin{frame}[fragile]{Nested query in C++}
%% \vspace{0.5 cm}
%% {\bf Example query:}
%% \begin{center}
%% \begin{minipage}{0.95\linewidth}
%% \textcolor{darkblue}{``Momentum of the track with $|\eta|$ $<$ 2.4 that has the most hits.''}
%% \end{minipage}
%% \end{center}
%% \small
%% \begin{minted}{c++}
%% Track *best = NULL;
%% for (int i = 0;  i < tracks.size();  i++) {
%%   if (fabs(tracks[i]->eta) < 2.4)
%%     if (best == NULL ||
%%         tracks[i]->hits.size() > best->hits.size())
%%       best = tracks[i];
%% }
%% if (best != NULL)
%%   return best->pt;
%% else
%%   return 0.0;
%% \end{minted}
%% \end{frame}

%% \begin{frame}[fragile]{Nested query in Femtocode}
%% \vspace{0.5 cm}
%% {\bf Example query:}
%% \begin{center}
%% \begin{minipage}{0.95\linewidth}
%% \textcolor{darkblue}{``Momentum of the track with $|\eta|$ $<$ 2.4 that has the most hits.''}
%% \end{minipage}
%% \end{center}
%% \small
%% \begin{onlyenv}<1>
%% \begin{minted}{scala}
%% event.tracks
%%      .filter(t => abs(t.eta) < 2.4)
%%      .maxBy(t => t.hits.size)
%%      .map(t => t.pt)
%%      .impute(0.0)
%% \end{minted}
%% \end{onlyenv}
%% \begin{onlyenv}<2>
%% \begin{minted}{bash}
%% event.tracks
%%      .filter(abs($1.eta) < 2.4)
%%      .maxBy($1.hits.size)
%%      .map($1.pt)
%%      .impute(0.0)
%% \end{minted}
%% \end{onlyenv}
%% \end{frame}

\begin{frame}[fragile]{Femtocode}
\vspace{0.4 cm}
Combine the {\it implementation flexibility} of declarative languages like SQL with the {\it expressiveness} of a functional language for dealing with nested structure.

\vspace{0.5 cm}
{\bf Example use:}

\small
\begin{minted}{python}
h = db.dataset("ttbar-MC")
  .withColumn(varName = "<Femtocode goes here>")
  .filter("<Femtocode using varName>")
  .flatMap("<Femtocode changing nesting level>")
  .Label(hist1 = Bin(100, -5.0, 5.0, "<Femtocode>"),
         hist2 = Bin(20, 0.0, 100.0, "<Femtocode>"),
         hist3 = Bin(314, -pi, pi, "<Femtocode>"))
\end{minted}

\normalsize
followed by Python analysis on {\small\tt h[\textcolor{darkred}{"hist1"}]}, {\small\tt h[\textcolor{darkred}{"hist2"}]}\ldots

\vspace{0.1 cm}
\begin{uncoverenv}<2->
Everything in quotes is the statically checked and optimized big data pull; everything outside is flexible Python.

\vspace{0.1 cm}
Histogrammar ({\tt\small Label} and {\tt\small Bin}) is a key component.
\end{uncoverenv}
\end{frame}







\end{document}
